[
["index.html", "Psyc 7709 R Book Chapter 1 Preface", " Psyc 7709 R Book Matthew Crump 2019-03-16 Chapter 1 Preface This is book is part of the final project for PSYC 7709: Using R for Reproducibles Research in Psychology. The chapters involve both class notes on various R topics, as well as student contributed chapters about various R topics. "],
["basic-programming-in-r.html", "Chapter 2 Basic Programming in R 2.1 Variables 2.2 Vectors 2.3 Loops 2.4 Logical comparison 2.5 IF ELSE 2.6 Functions", " Chapter 2 Basic Programming in R This .rmd goes along with the building blocks screencast. Basic coding in R involves creating variables to store information, and then systematically manipulating the contents of variables to solve particular problems. Some of the basic coding building blocks are variables, logic, and loops. These three elements are combined together to produce an algorithm (set of steps) to solve a problem. 2.1 Variables Below is code block contains 1 line that does a bunch of things. It creates a variable with the name variable_name It stores the number 1 inside the variable using the assignment operator &lt;-, which looks like an arrow (think: a 1 goes into the variable) The hashtag allows us to comment the line to say what is happening. Anything after the comment turns green, and R does not attempt to run this part as code. Comments can be useful for helping other people read the code When you run this line, you will see a new variable listed in the Environment pane in R-studio variable_name &lt;- 1 #comment, this line stores a 1 in variable_name Variables can have most any name, but they can’t start with a number, special character or contain a space. # neither of these lines work, they will throw an error 1s &lt;- 3 my variable &lt;- 1 !s &lt;- 1 It is good practice to use descriptive variable names that tell you and anyone else reading the code what the variable is storing. Let’s say you want to create three variables for storing your first name, last name, and favorite color. Here are good and bad examples: # good examples first_name &lt;- &quot;Matt&quot; last_name &lt;- &quot;Crump&quot; favorite_color &lt;- &quot;hot pink&quot; # bad examples a &lt;- &quot;Matt&quot; temp_var &lt;- &quot;Crump&quot; cl &lt;- &quot;hot pink&quot; 2.1.1 Style guide It is a good idea to learn how to write good-looking code. This makes your code easier to read and easier for you and others to understand. There are different opinions about the style you should adopt. I recommend that you adopt the conventions in the tidyverse style guide, https://style.tidyverse.org. And, I will try to follow that style guide in examples that I make. 2.1.2 Double-checking your variable works As mentioned previously, if you have made a new variable, you should be able to see it listed in the Environment tab. You can also type the name of the variable into the console and press enter. If the variable exists, the console will print the contents of the variable. # Writing the variable name will cause R to print out it&#39;s contents first_name ## [1] &quot;Matt&quot; You can also use the print() function to accomplish the same goal. print(first_name) ## [1] &quot;Matt&quot; 2.1.3 Changing the contents of a variable Any time you assign &lt;- something new into an existing variable, the contents of the variable will change. Below we have three lines of code. By running this code block, R will follow the instructions in order. It will run the first line, then the second line, then the third line. first_name &lt;- &quot;Matt&quot; first_name &lt;- &quot;A&quot; first_name &lt;- &quot;B&quot; What is the final contents of the variable first_name? It will be the last thing that was put into that variable, in this case a B. We can check that by printing out first_name. first_name ## [1] &quot;B&quot; 2.1.4 Properties of variables As we go along we will learn about different kinds of variables in R. Each of them allow you to store different kinds of information in different formats. To illustrate the idea of different formats let’s look at these two variables. a_number &lt;- 1 a_character &lt;- &quot;1&quot; You can use the class() function to find out information about variables in R. class(a_number) ## [1] &quot;numeric&quot; Notice that a_number has the class numeric. This means that R will treat the contents as a number. class(a_character) ## [1] &quot;character&quot; However, a_character has a the class character. This means that R will treat the contents as text. If two variables contain numbers, then you can do math using the variables a &lt;- 1 b &lt;- 2 a+b ## [1] 3 If the variables contain text, then math won’t work a &lt;- &quot;1&quot; b &lt;- &quot;2&quot; a+b 2.1.5 Converting between numeric and character In some cases R will allow you to convert variable classes. For example, if you have a numeric variable, you can convert it to a character. Below, we put a 1 into a, then show it is a numeric. Afterward, we use the as.character() function to convert a into a character, and then show that a is now a character, rather than a number a &lt;- 1 class(a) ## [1] &quot;numeric&quot; a &lt;- as.character(a) class(a) ## [1] &quot;character&quot; 2.1.6 converting between character and numeric as.numeric can convert text into numbers, but the text needs to be a numeral in order for this to work a &lt;- &quot;1&quot; class(a) ## [1] &quot;character&quot; a &lt;- as.numeric(1) class(a) ## [1] &quot;numeric&quot; This won’t work. R doesn’t know that “one” means 1. So, it will return NA, which stands for not available. a &lt;- &quot;one&quot; a &lt;- as.numeric(a) 2.2 Vectors You will often want to store more than one thing inside a variable. One way to do this is using a vector. A vector can contain multiple elements, all of the same class. Create a vector using the c() function. some_numbers &lt;- c(4,5,3,7,8,2,1,4,5,6,4) If we print some_numbers, we can see it contains all the numbers we put into it. some_numbers ## [1] 4 5 3 7 8 2 1 4 5 6 4 2.2.1 indexing Once you have some numbers inside a vector, you may want to access individual elements. R uses square brackets [] for indexing particular slots in the vector (e.g., the number in a particular position from first to last in the vector) some_numbers[1] # returns first number ## [1] 4 some_numbers[2] # returns second number ## [1] 5 some_numbers[1:3] # returns the first three numbers ## [1] 4 5 3 R has really powerful indexing abilities. For example, consider the following: some_numbers[c(2,4)] ## [1] 5 7 We have put a vector c(2,4) inside the square brackets. This will allow us to return the contents in slot 2, and 4 of the vector. What about this one? some_numbers[c(1,1,1)] ## [1] 4 4 4 We have put a vector c(1,1,1) inside the square brackets. This will allow us to return the contents in slot 1 three times. We haven’t covered logic statements yet, but it is worth pointing out that you can use logical indexing in R. For example, the following will return elements in the vector that are larger than a particular value. some_numbers[some_numbers &gt; 4] ## [1] 5 7 8 5 6 2.2.2 assignment and indexing You can replace the contents of a vector at particular position using indexing. Here we remind ourselves of the original list of numbers inside some_numbers. Then we replace the number in position 1 with a 9, and print the variable to check that the replacement worked. some_numbers &lt;- c(4,5,3,7,8,2,1,4,5,6,4) some_numbers[1] &lt;- 9 some_numbers ## [1] 9 5 3 7 8 2 1 4 5 6 4 2.2.3 c is for combine The c() function stands for combine. We are telling R to combine all of the elements inside the function into a vector. # combines the numbers 1-5 into a a &lt;- c(1,2,3,4,5) # combine a with a 6 on the end # append to the last part of the vector a&lt;- c(a, 6) # multiple combines b &lt;- c(c(1,2,3),c(9,10,11)) 2.3 Loops Check R help for on Control Flow ?Control. for(){} for(loop control){do something each iteration} for(iterator in vector){ #do something } Loop control is defined in between the parentheses. The name of the iterator is placed on the left of in(can be assigned any name you want, does not need to be declared in advance). During the execution of the loop, the iterator takes on the values inside the vector which is placed on the right side of in. Specifically, the following is happening. Loop steps: 1. iterator &lt;- vector[1] 2. iterator &lt;- vector[2] 3. iterator &lt;- vector[3] 4. etc. The loop will automatically stop once it reaches the last item in the vector. The loop can be stopped before that using the break command. # Make a loop do something 5 times # i is the iterator # 1:5 creates a vector with 5 numbers in it, 1, 2, 3, 4, 5 # the loop will run 5 times, because there are five things to assign to i for(i in 1:5){ print(5) } ## [1] 5 ## [1] 5 ## [1] 5 ## [1] 5 ## [1] 5 # show the value of i each step of the loop for(i in 1:5){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # define the vector to loop over in advance my_sequence &lt;- 1:5 for(i in my_sequence){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # Reminder that i becomes the next value in the vector # your vector can have any order my_sequence &lt;- c(1,5,2,3,4) for(i in my_sequence){ print(i) } ## [1] 1 ## [1] 5 ## [1] 2 ## [1] 3 ## [1] 4 # index vector does not need to be numbers my_things &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) for(i in my_things){ print(i) } ## [1] &quot;A&quot; ## [1] &quot;B&quot; ## [1] &quot;C&quot; ## [1] &quot;D&quot; 2.3.1 Breaking a loop break stops a loop. Used with logical statements to define the conditions necessary to cause the break. for(i in 1:10){ if(i &lt;5){ print(i) } else{ break } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 2.3.2 While loops While loops run until a logical condition is met. Here there is no iterator, just a logic statement that needs to be met. This one prints i while i is less than 6. As soon as i becomes “not less than 6”, then the loop stops. Critically, inside the loop, the value of i increases each iteration. i &lt;- 1 # create an variable while (i &lt; 6) { print(i) i = i+1 #add one eachs step of the loop } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 2.3.3 Repeat loops Similar to while, but let’s do things until a condition is met. i&lt;-0 repeat{ i&lt;-i+1 print(i) if(i==5){ break } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 2.3.4 Examples Braces are not needed on one line for(i in 1:5) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Using the value of the iterator to assign in values systematically to another variable. # put 1 into the first five positions of x x &lt;- c() # create empty vector for(i in 1:5){ x[i] &lt;- 1 # assign 1 to the ith slot in x } x ## [1] 1 1 1 1 1 # put the numbers 1-5 in the first 5 positions of x x &lt;-c() for(i in 1:5){ x[i] &lt;- i } x ## [1] 1 2 3 4 5 Make your own counter, when you need one a &lt;- c(1,4,3,5,7,6,8,2) odd &lt;- c() counter &lt;- 0 for(i in a){ # i will the values of a in each position counter &lt;- counter+1 if(i%%2 != 0){ odd[counter] &lt;- &quot;odd&quot; } else { odd[counter] &lt;- &quot;even&quot; } } odd ## [1] &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;odd&quot; &quot;odd&quot; &quot;even&quot; &quot;even&quot; &quot;even&quot; # An alternative strategy a &lt;- c(1,4,3,5,7,6,8,2) odd &lt;- c() # 1:length(a) creates a sequence from 1 to length for(i in 1:length(a)){ if(a[i]%%2 != 0){ odd[i] &lt;- &quot;odd&quot; } else { odd[i] &lt;- &quot;even&quot; } } odd ## [1] &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;odd&quot; &quot;odd&quot; &quot;even&quot; &quot;even&quot; &quot;even&quot; Nesting loops for(i in 1:5){ for(j in 1:5){ print(c(i,j)) } } ## [1] 1 1 ## [1] 1 2 ## [1] 1 3 ## [1] 1 4 ## [1] 1 5 ## [1] 2 1 ## [1] 2 2 ## [1] 2 3 ## [1] 2 4 ## [1] 2 5 ## [1] 3 1 ## [1] 3 2 ## [1] 3 3 ## [1] 3 4 ## [1] 3 5 ## [1] 4 1 ## [1] 4 2 ## [1] 4 3 ## [1] 4 4 ## [1] 4 5 ## [1] 5 1 ## [1] 5 2 ## [1] 5 3 ## [1] 5 4 ## [1] 5 5 # example of using nested loops to fill the contents # of a matrix my_matrix &lt;- matrix(0,ncol=5,nrow=5) for(i in 1:5){ for(j in 1:5){ my_matrix[i,j] &lt;- i*j } } my_matrix ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 2 4 6 8 10 ## [3,] 3 6 9 12 15 ## [4,] 4 8 12 16 20 ## [5,] 5 10 15 20 25 break exits out of the immediate loop # the inside loop stops when i+j is greater than 5 # the outside loop keeps going sum_of_i_j &lt;- c() counter &lt;- 0 for(i in 1:5){ for(j in 1:5){ counter &lt;- counter+1 sum_of_i_j[counter] &lt;- i+j if(i+j &gt; 5){ break } } } sum_of_i_j ## [1] 2 3 4 5 6 3 4 5 6 4 5 6 5 6 6 2.4 Logical comparison Logic statements are used to compare two things, or two sets of things. The output of comparison is a TRUE or FALSE statment. If many things are being compared at once, the output could be many TRUE or FALSE statements for each comparison 2.4.1 equal to 1==1 # is 1 equal to 1? ## [1] TRUE 1==2 # is 1 equal to 2? ## [1] FALSE c(1,2,3) == c(2,1,3) # compares each element with each element ## [1] FALSE FALSE TRUE 1 == c(2,1,3) ## [1] FALSE TRUE FALSE 2.4.2 not equal to 1!=1 # is 1 equal to 1? ## [1] FALSE 1!=2 # is 1 equal to 2? ## [1] TRUE c(1,2,3) != c(2,1,3) # compares each element with each element ## [1] TRUE TRUE FALSE 1 != c(2,1,3) ## [1] TRUE FALSE TRUE 2.4.3 Greater than/ less than 1 &gt; 1 # is 1 greater than 1? ## [1] FALSE 5 &gt; 1 # is 5 greater than 1? ## [1] TRUE 3 &lt; 2 # is 3 less than 2? ## [1] FALSE 3 &lt; 1 # is 3 less than 1? ## [1] FALSE c(1,2,3) &gt; c(2,1,3) # ask the question element by element ## [1] FALSE TRUE FALSE c(1,2,3) &lt; c(2,1,3) ## [1] TRUE FALSE FALSE 2 &gt; c(1,2,3) # is greater than each of the numbers ## [1] TRUE FALSE FALSE 2.4.4 &gt;= &lt;= Is something greater than or equal to something else 1 &gt;= 1 # is 1 greater than 1? ## [1] TRUE 5 &gt;= 1 # is 5 greater than 1? ## [1] TRUE 3 &lt;= 2 # is 3 less than 2? ## [1] FALSE 3 &lt;= 1 # is 3 less than 1? ## [1] FALSE c(1,2,3) &gt;= c(2,1,3) # ask the question element by element ## [1] FALSE TRUE TRUE c(1,2,3) &lt;= c(2,1,3) ## [1] TRUE FALSE TRUE 2 &gt;= c(1,2,3) # is greater than each of the numbers ## [1] TRUE TRUE FALSE 2.4.5 AND The ampersand &amp; is used for AND, which allows use to evaluate whether two or more properties are all TRUE. # is 16 divisible by 4 AND 8 16%%4 == 0 &amp; 16%%8 ==0 ## [1] TRUE # is 16 divisible by 4 AND 3 16%%4 == 0 &amp; 16%%3 ==0 ## [1] FALSE # is 16 divisible by 8 and 4 and 2 16%%4 == 0 &amp; 16%%8 ==0 &amp; 16%%2 ==0 ## [1] TRUE 2.4.6 OR The | is used for OR, which allows use to evaluate at least one of the properties is TRUE. # is 16 divisible by 4 OR 8 16%%4 == 0 | 16%%8 ==0 ## [1] TRUE # is 16 divisible by 4 OR 3 # it is divisible by 4, so the answer is TRUE # because at least one of the comparisons is TRUE 16%%4 == 0 | 16%%3 ==0 ## [1] TRUE 2.4.7 TRUE FALSE When R returns values as TRUE or FALSE, it return a logical variable. It also treats TRUE as a 1, and FALSE as a 0. In the example below we see it is possible sum up a logical variable with multiple TRUE and FALSE entries. c(1,2,3) == c(1,2,3) ## [1] TRUE TRUE TRUE sum(c(1,2,3) == c(1,2,3)) ## [1] 3 c(1,2,3) == c(2,1,3) ## [1] FALSE FALSE TRUE sum(c(1,2,3) == c(2,1,3)) ## [1] 1 2.5 IF ELSE A carnival operator needs to check if people are taller than a line to see if they can ride the ride. Every time someone goes through the gate, they run an IF ELSE control structure in their head. IF the person is taller than the line, then they can go on the ride; ELSE (otherwise) the person can not go on the ride. In other words, IF the situation is X, then do something; ELSE (if the situation is not X), then do something different. IF and ELSE statements let us specify the conditions when specific actions are taken. Generally, IF and ELSE statements are used inside loops (for, or while, or repeat loops), because at each step or iteration of the loop, we want to check something, and then do something. Consider this: a &lt;- 1 # define a to be a 1 if(a==1){ print(a) # this is what happens if a==1 } else { print(&quot;A is not 1&quot;) # this is what happens if a is not 1 } ## [1] 1 a &lt;- 2 # define a to be a 1 if(a==1){ print(a) # this is what happens if a==1 } else { print(&quot;A is not 1&quot;) # this is what happens if a is not 1 } ## [1] &quot;A is not 1&quot; Normally we find IF and ELSE in a loop like this: a &lt;- c(1,0,1,0,0,0,1) # make a variable contain 1s and 0s # write a loop to check each element in the variable # and do different things depending on the element for(i in a){ if(i == 1){ print(&quot;I&#39;m a 1&quot;) # what to do when i is 1 } else { print(&quot;I&#39;m not a 1&quot;) # what to do when i is not 1 } } ## [1] &quot;I&#39;m a 1&quot; ## [1] &quot;I&#39;m not a 1&quot; ## [1] &quot;I&#39;m a 1&quot; ## [1] &quot;I&#39;m not a 1&quot; ## [1] &quot;I&#39;m not a 1&quot; ## [1] &quot;I&#39;m not a 1&quot; ## [1] &quot;I&#39;m a 1&quot; We can have multiple conditions in our if statements. a &lt;- c(1,2,3,1,2,0,1) # make a variable contain 1s and 0s # write a loop to check each element in the variable # and do different things depending on the element for(i in a){ if(i == 1){ print(&quot;I&#39;m a 1&quot;) # what to do when i is 1 } else if (i==2){ print(&quot;I&#39;m a 2&quot;) # what to do when i is 2 } else if (i==3){ print(&quot;I&#39;m a 3&quot;) # what to do when i is 3 } else { print(&quot;I&#39;m not any of the above&quot;) #what to do when none are true } } ## [1] &quot;I&#39;m a 1&quot; ## [1] &quot;I&#39;m a 2&quot; ## [1] &quot;I&#39;m a 3&quot; ## [1] &quot;I&#39;m a 1&quot; ## [1] &quot;I&#39;m a 2&quot; ## [1] &quot;I&#39;m not any of the above&quot; ## [1] &quot;I&#39;m a 1&quot; 2.6 Functions This section discusses the syntax for writing custom functions in R. 2.6.1 function syntax function_name &lt;- function(input1,input2){ #code here return(something) } 2.6.2 example functions This function has no input between the (). Whenever you run this function, it will simply return whatever is placed inside the return statement. # define the function print_hello_world &lt;- function(){ return(print(&quot;hello world&quot;)) } # use the function print_hello_world() ## [1] &quot;hello world&quot; This function simply takes an input, and then returns the input without modifying it. return_input &lt;- function(input){ return(input) } # the variable input is assigned a 1 # then we return(input), which will result in a 1 # because the function internally assigns 1 to the input return_input(1) ## [1] 1 a &lt;- &quot;something&quot; return_input(a) ## [1] &quot;something&quot; This function takes an input, then creates an internal variable called temp and assigns input+1. Then the contents of temp is returned. Note there, is no checking of the input, so it will return an erro if you input a character (can’t add one to a character in R) add_one &lt;- function(input){ temp &lt;- input+1 return(temp) } add_one(1) ## [1] 2 add_one(&quot;a&quot;) ## Error in input + 1: non-numeric argument to binary operator This function adds some input checking. We only add one if the input is a numeric type. Otheriwse, we use stop() to return an error message to the console add_one &lt;- function(input){ if(class(input) == &quot;numeric&quot;){ temp &lt;- input+1 return(temp) } else { return(stop(&quot;input must be numeric&quot;)) } } add_one(1) ## [1] 2 add_one(&quot;a&quot;) ## Error in add_one(&quot;a&quot;): input must be numeric A function with three inputs add_multiply &lt;- function(input, x_plus,x_times){ temp &lt;- (input+x_plus)*x_times return(temp) } # input is 1 # x_plus &lt;- 2 # x_times &lt;- 3 # will return (1+2)*3 = 9 add_multiply(1,2,3) ## [1] 9 "],
["programming-challenges-for-learning-the-fundamentals.html", "Chapter 3 Programming Challenges for learning the fundamentals 3.1 Tips for Approaching the Problems 3.2 Easier Problems 3.3 Harder Problems", " Chapter 3 Programming Challenges for learning the fundamentals What is the purpose of these problems, and why should you try to solve them? An important overarching goal in learning to code is to become justifiably confident in your ability to write scripts to solve problems. At the end of the day you will be applying your skills to new problems without textbook answers, and your ability to solve these problems rests in learning how to write new code that works. This is not an abstract problem, and instead requires practice with writing code to solve new problems. The following problem sets are designed primarily with this aim in mind. Solving these problems will simultaneously develop your ability to write scripts to solve new problems, as well as give you hands on exposure to learning the syntax of the R language. These problems are not written specifically for the R language, and the solving the same problems in another language is a useful strategy for learning the syntax of another language. The problems are roughly ordered in terms of difficulty, with easier problems first and harder problems second. All of the problems can be solve by combining the foundational programming concepts already discussed. That is, they can be solved by declaring variables, using logic statements, and for loops to create algorithms that solve each problem. Some of the problems require writing functions, which is a more formal and general way of writing algorithms. Many of the problems can be solved very quickly and efficiently by writing only a few lines of code, and by using intrinsic functions already supplied by the R programming language. For each of the problems you might consider writing different solutions to explore different syntax options. 3.1 Tips for Approaching the Problems Before you begin solving each of the problems it is worth considering how you will organize your solutions. This is important, as the code that you write now may become useful as a reference later, and to use the reference you will want to be able to find your code quickly and easily in the future. An example of bad practice here is to save your solutions to your desktop or other random folder on your computer. Instead, create a programming folder (or something similar), and organize your progress by saving informatively named files to appropriately named subfolders. 3.1.1 Rstudio’s Text editor You should be making use of R studio’s text editor to complete the problem sets. It is important to establish good coding practices from the very beginning. Make sure that your code is easy to read. This will help you understand your own code later, and help other people understand your code when sharing it or when asking for help. 3.1.2 Use informative variable names. You will be declaring many different kinds of variables. R usually will not care what name you give to any variable. Oftentimes scripts can be written very quickly when variables are declared with names like a, b, i, or x (which are common variable names in algebra). These kinds of variable names are not very informative, and it is preferable to give names that represent the meaning of the data stored in each variable. 3.1.3 Use comments. You can insert comments into your scripts. In R, all text following the number sign # will turn to green (become commented out), and will not be compiled by R when the code is run. Comments are useful for explaining to yourself and to others what various parts of the script are accomplishing (or attempting to accomplish). Clear and easy follow code generally contains useful (and non-redundant comments). 3.1.4 R Markdown. R studio’s text editor allows for the creation of markdown files. Markdown is a very simple short-form language for creating HTML documents that can be viewed in a web-browser, or printed as a .pdf. This is an extremely powerful tool because it combines the power of a simple word-processor, with the power of R. In practice, this means that you can write documents with titles, headings, paragraphs, and sentences, and include in these documents the R-scripts that you are writing, and the output of these scripts. Thinking ahead, when you are using R to transform and analyse your own data, it is possible to create a data-journal to combine all of your efforts into one document. For example, a data-journal could include notes on the design of the experiment, links to the data, notes about pre-processing considerations, code use to pre-process the data, notes on statistical tests, code to run them along with the output from the tests, thoughts on how to present the data along with journal-quality figures formatted to specific sizes, and so on. To make use of Markdown, it is recommended that you create a single markdown document, that will list each of the problems and your solutions. 3.2 Easier Problems Do simple math with numbers, addition, subtraction, multiplication, division Put numbers into variables, do simple math on the variables Write code that will place the numbers 1 to 100 separately into a variable using for loop. Then, again using the seq function. Find the sum of all the integer numbers from 1 to 100. you can use the sum() function on a vector of numbers How would you do this without using the sum function? For example, how could you use a for loop to accomplish this task? Write a function to find the sum of all integers between any two values. # syntax for writing a function function_name &lt;- function(input_name){ #body where you modify input return(name_of_output) } # running the function function_name(some_input) List all of the odd numbers from 1 to 100. you could use the seq() function How could you do this without using the seq() function? Consider using the mod function %%, which evaluates whether or not there is a remainder when dividing one number by another. # four divided by two gives no remainder # the mod function shows 0 4%%2 ## [1] 0 # 5 divided by two gives a remainder # the mod function shows 1 5%%2 ## [1] 1 List all of the prime numbers from 1 to 1000. Generate 100 random numbers check out the runif function to look at the help file run ?runif in the console. In general ?function_name will show the help file for any function in R. Generate 100 random numbers within a specific range runif can do this Write your own functions to give descriptive statistics for a vector variable storing multiple numbers. Write functions for the following without using R intrinsics: mean, mode, median, range, standard deviation It’s ok to use sum() and length() be creative and see if you can find multiple solutions. Here is an example for two ways to compute the mean. # using sum and length mean_A &lt;- function(x){ return(sum(x)/length(x)) } some_numbers &lt;- c(1,2,3,4,5) mean_A(some_numbers) ## [1] 3 # no intrinsics mean_B &lt;- function(x){ counter &lt;- 0 total_sum &lt;-0 for(i in x){ total_sum &lt;- total_sum+i counter&lt;-counter+1 } return(total_sum/counter) } mean_B(some_numbers) ## [1] 3 Count the number of characters in a string variable use strsplit() to split a character vector a &lt;- &quot;adskfjhkadsjfh&quot; strsplit(a,split=&quot;&quot;) ## [[1]] ## [1] &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;k&quot; &quot;f&quot; &quot;j&quot; &quot;h&quot; &quot;k&quot; &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;j&quot; &quot;f&quot; &quot;h&quot; # note that strsplit returns it&#39;s result in a list b &lt;-strsplit(a,split=&quot;&quot;) b[[1]] # access all elements in list 1 ## [1] &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;k&quot; &quot;f&quot; &quot;j&quot; &quot;h&quot; &quot;k&quot; &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;j&quot; &quot;f&quot; &quot;h&quot; b[[1]][1] # access first element of list 1 ## [1] &quot;a&quot; # lists can be unlisted d &lt;- unlist(strsplit(a,split=&quot;&quot;)) d # all elements in character vector ## [1] &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;k&quot; &quot;f&quot; &quot;j&quot; &quot;h&quot; &quot;k&quot; &quot;a&quot; &quot;d&quot; &quot;s&quot; &quot;j&quot; &quot;f&quot; &quot;h&quot; d[1] #first element ## [1] &quot;a&quot; Count the number of words in a string variable use strsplit a &lt;- &quot;this is a sentence&quot; strsplit(a,split=&quot; &quot;) # use a space as the splitting character ## [[1]] ## [1] &quot;this&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; Count the number of sentences in a string variable consider splitting by the . character Count the number of times a specific character occurs in a string variable table() function can help count individual occurences a &lt;- c(1,3,2,3,2,3,2,3,4,5,4,3,4,3,4,5,6,7) table(a) ## a ## 1 2 3 4 5 6 7 ## 1 3 6 4 2 1 1 How would you do this without the table function? Do a logical test to see if one word is found within the text of another string variable. For example given the word hello, can you run a test to see if it is contained in the test sentence? test_word &lt;- &quot;hello&quot; test_sentence &lt;-&quot;is the word hello in this sentence&quot; consider using %in% a &lt;- c(1,2,3,4,5) b &lt;- 5 d &lt;- 8 # question is b in a? b%in%a ## [1] TRUE # is d in a? d%in%a ## [1] FALSE Put the current computer time in milliseconds into a variable print(as.numeric(Sys.time())*1000, digits=15) ## [1] 1552741000498.26 Measure how long a piece of code takes to run by measuring the time before the code is run, and after the code is run, and taking the difference to find the total time Read a .txt file or .csv file into a variable scan() is a general purpose text input function read.csv() will read .csv files Output the contents of a variable to a .txt file write.csv() Create a variable that stores a 20x20 matrix of random numbers here’s how you make a matrix full of 0s a &lt;- matrix(0, ncol=20,nrow=20) Output any matrix to a txt file using commas or tabs to separate column values, and new lines to separate row values write.csv() 3.3 Harder Problems The FizzBuzz Problem. List the numbers from 1 to 100 with the following constraints. If the number can be divided by three evenly, then print Fizz instead of the number. If the number can be divided by five evenly, then print Buzz instead of the number. Finally, if the number can be divided by three and five evenly, then print FizzBuzz instead of the number. The answer could look something like this: 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, Fizz, 22, 23, Fizz, Buzz, 26, Fizz, 28, 29, FizzBuzz, 31, 32, Fizz, 34, Buzz, Fizz, 37, 38, Fizz, Buzz, 41, Fizz, 43, 44, FizzBuzz, 46, 47, Fizz, 49, Buzz, Fizz, 52, 53, Fizz, Buzz, 56, Fizz, 58, 59, FizzBuzz, 61, 62, Fizz, 64, Buzz, Fizz, 67, 68, Fizz, Buzz, 71, Fizz, 73, 74, FizzBuzz, 76, 77, Fizz, 79, Buzz, Fizz, 82, 83, Fizz, Buzz, 86, Fizz, 88, 89, FizzBuzz, 91, 92, Fizz, 94, Buzz, Fizz, 97, 98, Fizz, Buzz Here a few bits that might be useful # a number mod three will return 0 if it divides evenly 6%%3 ## [1] 0 # a number mod five will return 0 if it divides evenly 10%%5 ## [1] 0 # examples of replacing elements of a vector a&lt;-c(1,2,3,4,5) a[3]&lt;-&quot;Fizz&quot; a ## [1] &quot;1&quot; &quot;2&quot; &quot;Fizz&quot; &quot;4&quot; &quot;5&quot; # notice that a starts as a numeric vector # but changes to an all character vector after &quot;Fizz&quot; is added Frequency Counts Take text as input, and be able to produce a table that shows the counts for each character in the text. This problem is related to the earlier easy problem asking you to count the number of times that a single letter appears in a text. The slightly harder problem is the more general version: count the frequencies of all unique characters in a text. here’s the easy way to do this a&lt;-&quot;some text that has some letters&quot; table(unlist(strsplit(a,split=&quot;&quot;))) ## ## a e h l m o r s t x ## 5 2 5 2 1 2 2 1 4 6 1 Can you do this without using table? Attempt this problem using data.frame. Here are some more tips # data.frame is data format that produces named columns of data # creates two vectors numbers &lt;-c(1,2,3,4,5) letters &lt;-c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) # make a data.frame from two vectors new_df &lt;- data.frame(numbers,letters) print(new_df) ## numbers letters ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e # access individual columns of dataframe new_df$numbers ## [1] 1 2 3 4 5 new_df$letters ## [1] a b c d e ## Levels: a b c d e # get names of data.frame names(new_df) ## [1] &quot;numbers&quot; &quot;letters&quot; # break the problem into steps # first part of problem is to identify all unique character in the string a&lt;-c(1,2,3,4,5,2,2,3,2,3) unique(a) ## [1] 1 2 3 4 5 b&lt;-&quot;a string with some letters&quot; unique(unlist(strsplit(b,split=&quot;&quot;))) ## [1] &quot;a&quot; &quot; &quot; &quot;s&quot; &quot;t&quot; &quot;r&quot; &quot;i&quot; &quot;n&quot; &quot;g&quot; &quot;w&quot; &quot;h&quot; &quot;o&quot; &quot;m&quot; &quot;e&quot; &quot;l&quot; # second part is to go through each of the unique letters in the list of unique letters, and for each count the number of times they appear in the original text # store the results in a data.frame with two columns, one with the letter names, and another with the counts Test the Random Number Generator Test the random number generator for a flat distribution. Generate a few million random numbers between 0 and 100. Count the number of 0s, 1s, 2s, 3s, etc. all the way up to 100. Look at the counts for each of the numbers and determine if they are relatively equal. For example, you could plot the counts in Excel to make a histogram. If all of the bars are close to being flat, then each number had an equal chance of being selected, and the random number generator is working without bias. Figure 3.1: Histogram showing sampled data from a uniform distribution a&lt;-runif(100,0,100) hist(a) Create a multiplication table Generate a matrix for a multiplication table. For example, the labels for the columns could be the numbers 1 to 10, and the labels for the rows could be the numbers 1 to 10. The contents of each of the cells in the matrix should be correct answer for multiplying the column value by the row value. # you can multiply all numbers in a vector in one go a&lt;-c(1,2,3,4,5,6,7,8,9,10) a*2 ## [1] 2 4 6 8 10 12 14 16 18 20 # you can nest loops for(i in 1:3){ for(j in 1:3){ print(i*j) } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 3 ## [1] 6 ## [1] 9 Encrypt and Decrypt the Alphabet Turn any normal english text into an encrypted version of the text, and be able to turn any decrypted text back into normal english text. A simple encryption would be to scramble the alphabet such that each letter corresponds to a new randomly chosen (but unique) letter. The following code shows an example using numbers original_sequence &lt;- c(1,2,3,4,5,2,2,3,2,4,5,2) numbers &lt;- unique(original_sequence) scrambled_numbers &lt;- sample(numbers) encryption_key &lt;- data.frame(numbers,scrambled_numbers) encrypt_numbers &lt;-function(input_sequence,key){ encrypted_sequence&lt;-c() for(i in 1:length(input_sequence)){ original_number &lt;- input_sequence[i] new_number &lt;- key[key$numbers==original_number,]$scrambled_numbers encrypted_sequence[i] &lt;- new_number } return(encrypted_sequence) } encrypt_numbers(original_sequence,encryption_key) ## [1] 1 2 5 3 4 2 2 5 2 3 4 2 here is a different approach making use of the factor() function original_sequence &lt;- c(1,2,3,4,5,2,2,3,2,4,5,2) original_sequence &lt;- as.factor(original_sequence) levels(original_sequence) # show names of levels in factor ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; new_sequence &lt;- original_sequence # copy levels(new_sequence)&lt;-c(5,4,3,2,1) # rename the levels new_sequence # all elements are now changed ## [1] 5 4 3 2 1 4 4 3 4 2 1 4 ## Levels: 5 4 3 2 1 Snakes and Ladders Your task here is to write an algorithm that can simulate playing the above depicted Snakes and Ladders board. You should assume that each roll of the dice produces a random number between 1 and 6. After you are able to simulate one played game, you will then write a loop to simulate 1000 games, and estimate the average number of dice rolls needed to successfully complete the game. # rolling a dice with sample sample(c(1,2,3,4,5,6),1) ## [1] 5 sample(c(1,2,3,4,5,6),1) ## [1] 6 sample(c(1,2,3,4,5,6),1) ## [1] 1 -tip: consider a simpler version of the problem. How many times do you need to roll a dice so that all of the dice rolls add up to 25 or greater? # try one simulation total_sum&lt;-0 number_of_rolls&lt;-0 while(total_sum &lt; 25){ number_of_rolls &lt;- number_of_rolls+1 total_sum &lt;-total_sum+sample(c(1,2,3,4,5,6),1) } number_of_rolls ## [1] 9 # record the results from multiple simulations save_rolls &lt;- c() for(sims in 1:100){ total_sum&lt;-0 number_of_rolls&lt;-0 while(total_sum &lt; 25){ number_of_rolls &lt;- number_of_rolls+1 total_sum &lt;-total_sum+sample(c(1,2,3,4,5,6),1) } save_rolls[sims] &lt;- number_of_rolls } mean(save_rolls) ## [1] 7.69 how do you add in a representaion of the board, so that you change which square the player is on depending on whether they land on a ladder or snake. Dice-rolling simulations. Assume that a pair of dice are rolled. Using monte carlo-simulation, compute the probabilities of rolling a 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, and 12, respectively. Monte Hall problem. The monte-hall problem is as follows. A contestant in a game show is presented with three closed doors. They are told that a prize is behind one door, and two goats are behind the other two doors. They are asked to choose which door contains the prize. After making their choice the game show host opens one of the remaining two doors (not chosen by the contestant), and reveals a goat. There are now two door remaining. The contestant is asked if they would like to switch their choice to the other door, or keep their initial choice. The correct answer is that the participant should switch their initial choice, and choose the other door. This will increase their odds of winning. Demonstrate by monte-carlo simulation that the odds of winning is higher if the participant switches than if the participants keeps their original choice. 100 doors problem. Problem: You have 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, you visit every door and toggle the door (if the door is closed, you open it; if it is open, you close it). The second time you only visit every 2nd door (door 2, 4, 6, etc.). The third time, every 3rd door (door 3, 6, 9, etc.), etc, until you only visit the 100th door. Question: What state are the doors in after the last pass? Which are open, which are closed? 99 Bottles of Beer Problem In this puzzle, write code to print out the entire “99 bottles of beer on the wall”\" song. For those who do not know the song, the lyrics follow this form: X bottles of beer on the wall X bottles of beer Take one down, pass it around X-1 bottles of beer on the wall Where X and X-1 are replaced by numbers of course, from 99 all the way down to 0. Random Tic-Tac-Toe Imagine that two players make completely random choices when playing tic-tac-toe. Each game will either end in a draw or one of the two players will win. Create a monte-carlo simulation of this “random” version of tic-tac-toe. Out 10,000 simulations, what proportion of the time is the game won versus drawn? "],
["data-visualization-ggplot2.html", "Chapter 4 Data visualization (ggplot2) 4.1 ggplot2 resources 4.2 Example code 4.3 Advanced ggplot 4.4 knitr options 4.5 Data-vis assignment with solutions 4.6 List of Figures to reproduce", " Chapter 4 Data visualization (ggplot2) Make sure you load ggplot2 before you try to use it in your rmd file. library(ggplot2) 4.1 ggplot2 resources ggplot2 reference website Hadley Wickham’s, R for Data Science, Chapter 3 Data visualization ggplot2 cheatsheet 4.2 Example code 4.2.1 Scatterplot # Create dataframe a &lt;- c(1,2,3,2,3,4,5,4) b &lt;- c(4,3,4,3,2,1,2,3) plot_df &lt;- data.frame(a,b) # basic scatterplot ggplot(plot_df, aes(x=a,y=b))+ geom_point() # customize, add regression line ggplot(plot_df, aes(x=a,y=b))+ geom_point(size=2)+ geom_smooth(method=lm)+ coord_cartesian(xlim=c(0,7),ylim=c(0,10))+ xlab(&quot;x-axis label&quot;)+ ylab(&quot;y-axis label&quot;)+ ggtitle(&quot;I made a scatterplot&quot;)+ theme_classic(base_size=12)+ theme(plot.title = element_text(hjust = 0.5)) 4.2.2 bar graph 1 factor #Create a dataframe factor_one &lt;- as.factor(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) dv_means &lt;- c(20,30,40) dv_SEs &lt;- c(4,3.4,4) plot_df &lt;- data.frame(factor_one, dv_means, dv_SEs) # basic bar graph ggplot(plot_df, aes(x=factor_one,y=dv_means))+ geom_bar(stat=&quot;identity&quot;) # adding error bars, customizing ggplot(plot_df, aes(x=factor_one,y=dv_means))+ geom_bar(stat=&quot;identity&quot;)+ geom_errorbar(aes(ymin=dv_means-dv_SEs, ymax=dv_means+dv_SEs), width=.2)+ coord_cartesian(ylim=c(0,100))+ xlab(&quot;x-axis label&quot;)+ ylab(&quot;y-axis label&quot;)+ ggtitle(&quot;I made a bar graph&quot;)+ theme_classic(base_size=12)+ theme(plot.title = element_text(hjust = 0.5)) 2 factor #Create a dataframe factor_one &lt;- rep(as.factor(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)),2) factor_two &lt;- rep(as.factor(c(&quot;IIA&quot;,&quot;IIB&quot;)),3) dv_means &lt;- c(20,30,40,20,40,40) dv_SEs &lt;- c(4,3.4,4,3,2,4) plot_df &lt;- data.frame(factor_one, factor_two, dv_means, dv_SEs) # basic bar graph ggplot(plot_df, aes(x=factor_one,y=dv_means, group=factor_two, color=factor_two))+ geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;) # adding error bars, customizing ggplot(plot_df, aes(x=factor_one,y=dv_means, group=factor_two, color=factor_two, fill=factor_two))+ geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ geom_errorbar(aes(ymin=dv_means-dv_SEs, ymax=dv_means+dv_SEs), position=position_dodge(width=0.9), width=.2, color=&quot;black&quot;)+ coord_cartesian(ylim=c(0,100))+ xlab(&quot;x-axis label&quot;)+ ylab(&quot;y-axis label&quot;)+ ggtitle(&quot;Bar graph 2 factors&quot;)+ theme_classic(base_size=12)+ theme(plot.title = element_text(hjust = 0.5)) 3 factor #Create a dataframe factor_one &lt;- rep(rep(as.factor(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)),2),2) factor_two &lt;- rep(rep(as.factor(c(&quot;IIA&quot;,&quot;IIB&quot;)),3),2) factor_three &lt;- rep(as.factor(c(&quot;IIIA&quot;,&quot;IIIB&quot;)),each=6) dv_means &lt;- c(20,30,40,20,40,40, 10,20,50,50,10,10) dv_SEs &lt;- c(4,3.4,4,3,2,4, 1,2,1,2,3,2) plot_df &lt;- data.frame(factor_one, factor_two, factor_three, dv_means, dv_SEs) # basic bar graph ggplot(plot_df, aes(x=factor_one,y=dv_means, group=factor_two, color=factor_two))+ geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ facet_wrap(~factor_three) 4.2.3 Line Graph 1 factor #Create a dataframe factor_one &lt;- as.factor(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) dv_means &lt;- c(20,30,40) dv_SEs &lt;- c(4,3.4,4) plot_df &lt;- data.frame(factor_one, dv_means, dv_SEs) # basic line graph ggplot(plot_df, aes(x=factor_one,y=dv_means, group=1))+ geom_point()+ geom_line() # adding error bars, customizing ggplot(plot_df, aes(x=factor_one,y=dv_means, group=1))+ geom_point()+ geom_line()+ geom_errorbar(aes(ymin=dv_means-dv_SEs, ymax=dv_means+dv_SEs), width=.2)+ coord_cartesian(ylim=c(0,100))+ xlab(&quot;x-axis label&quot;)+ ylab(&quot;y-axis label&quot;)+ ggtitle(&quot;I made a line graph&quot;)+ theme_classic(base_size=12)+ theme(plot.title = element_text(hjust = 0.5)) 2 factor #Create a dataframe factor_one &lt;- rep(as.factor(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)),2) factor_two &lt;- rep(as.factor(c(&quot;IIA&quot;,&quot;IIB&quot;)),3) dv_means &lt;- c(20,30,40,20,40,40) dv_SEs &lt;- c(4,3.4,4,3,2,4) plot_df &lt;- data.frame(factor_one, factor_two, dv_means, dv_SEs) # basic line graph ggplot(plot_df, aes(x=factor_one,y=dv_means, group=factor_two, color=factor_two, linetype=factor_two))+ geom_point()+ geom_line() 4.2.4 Histogram base R a&lt;-rnorm(100,0,1) hist(a) score &lt;- rnorm(100,0,1) n &lt;- 1:100 plot_df &lt;- data.frame(score,n) ggplot(plot_df, aes(x=score))+ geom_histogram(bins=10, color=&quot;white&quot;) 4.3 Advanced ggplot 4.3.1 Add-on packages https://www.ggplot2-exts.org A repository of 50+ add on packages for ggplot2 https://gganimate.com allows you to create animated .gifs of ggplots I made a bunch of animated gifs for a statistics textbook. They are all here along with the code https://crumplab.github.io/statistics/gifs.html ggrepel allows you to repel overlapping text labels away from each other. esquisse a GUI (graphic user interface) that allows you make ggplot graphs using drag-drop, and clickable options ggedit similar to above, clickable editing of ggplot graphs plotly a package similar to ggplot, makes a whole variety of graphs, mainly for use in websites. Allows interactive graphs. As an example, I used plotly on my publications website, if you hover over the dots, info pops up https://crumplab.github.io/Publications.html. ggpubr (install from CRAN), many useful things, including the ggarrange function which allows you to knit multiple plots together ggthemes extra themes, scales, and geoms 4.3.2 Figure Output tips How do you control the size (width/height) of the figure, and where can you can get a file, like a .pdf or a .png of the figure? I use knitr options to solve these problems. 4.4 knitr options When you create a new R Markdown document you will see the following code chunk underneath the yaml, at the beginning of the document. It usually looks like this: ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` This chunk is named setup, it is not printed in your output, but it controls the global setup options for the whole document. Any option you set here applies to all of the remaining code chunks you create. It’s a way of setting defaults. Here are some helpful defaults you can add. You turn the option on with TRUE, and turn it off with FALSE. echo=TRUE sets the default to print all remaining code blocks to the output, FALSE sets the default to not print the code blocks warning = FALSE turns off printing of warnings message = FALSE turns off printing of messages, these commonly occur when you load a package, where you receive a message that the package was loaded eval = FALSE sets the default to NOT evaluate the code chunk as R Code. This will not run the code block, but the code block will still print if echo=TRUE error=TRUE normally the knit fails when there is an error in the code. If you set error=TRUE the knit will complete, and return an error message for code blocks with errors. ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE, error = TRUE) ``` 4.4.1 knitr figure output defaults The following setup options are useful for figure output. fig.width = 3 sets the default width in inches for all figures fig.height = 3 sets the default height in inches for all figures fig.path = \"myfigs/\" defines folder where figure files will be saved. This will be relative to your current working directoy dev = c(\"pdf\", \"png\") tells knitr to output both .png, and .pdf versions of the figure. The .pdf contains vector graphics, meaning the figure can be resized without pixelization. ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE, fig.width = 3, fig.height = 3, fig.path = &quot;myfigs/&quot;, dev = c(&quot;pdf&quot;, &quot;png&quot;)) ``` 4.4.2 figure output per code block You can set the options for remaining code blocks individually. These will overrule the default options that you specify in the setup chunk. `markdown{r figurename, fig.width =5, fig.height =7} 4.5 Data-vis assignment with solutions This assignment contains several figures that were recently published in the January 2019 issue of Psychological Science. Although, this sample of figures is somewhat arbitrary, they represent a decent range of figures that are produced in Psychological research. Notably, the look and feel of these graphs suggests that that they were all made in R using the ggplot2 package. And even if they weren’t, they can all be made in ggplot2. Your task is to write code to reproduce each of the graphs using ggplot2. You do not have the original data for any of these graphs, and your job is to make inferences about what the data must have been. For each graph you will create a data.frame to mimic the data you see in the graph, and then use ggplot2 to make the plot. By the end of this exercise you will become much more familiar with how ggplot2 works, and you will have created several examples of working ggplot2 scripts that you can use for making graphs in the future. 4.6 List of Figures to reproduce Calcutt, S. E., Proctor, D., &amp; Berman, S. M. (2019). Chimpanzees (Pan troglodytes) Are More Averse to Social Than Nonsocial Risk. Psychological Science, 30, 105–115. library(ggplot2) library(ggrepel) chimps&lt;-rep(c(&quot;Dara&quot;,&quot;Rita&quot;,&quot;Liza&quot;,&quot;Katie&quot;,&quot;Azalea&quot;,&quot;Barbi&quot;,&quot;Rowena&quot;,&quot;Fiona&quot;), each=2) MF &lt;- c(59,60,51,57,48,33,3,4,23,43,1,42,3,38,0,10) Condition &lt;- rep(c(&quot;Social Condition&quot;,&quot;Nonsocial Condition&quot;),8) Aversity &lt;- rep(c(&quot;Not Averse&quot;,&quot;Averse&quot;),each=8) plot_df &lt;- data.frame(chimps, MF, Condition, Aversity, chimps2=chimps) plot_df$chimps2[c(2,4,6,8,9,11,13,15)]&lt;-&quot;&quot; plot_df$Condition &lt;- factor(plot_df$Condition, levels = c(&quot;Social Condition&quot;,&quot;Nonsocial Condition&quot;)) #note the commented code shows an example of using text repel to make the labels non overlapping. ggplot(plot_df, aes(x=Condition, y=MF, linetype=Aversity, group=chimps, label=chimps2))+ geom_line()+ theme_classic(base_size=13)+ xlab(&quot;&quot;)+ ylab(&quot;Mean Frequency of Risky Choice&quot;)+ theme(legend.position=&quot;none&quot;) + scale_y_continuous(breaks=seq(0,70,10), expand=c(0,0))+ coord_cartesian(ylim=c(0,70))+ #geom_text_repel(size=3,aes(label=chimps2))+ annotate(&quot;text&quot;, x = .8, y = 60, label = &quot;Dara&quot;)+ annotate(&quot;text&quot;, x = .8, y = 53, label = &quot;Rita&quot;)+ annotate(&quot;text&quot;, x = .8, y = 47, label = &quot;Liza&quot;)+ annotate(&quot;text&quot;, x = .8, y = 3, label = &quot;Katie&quot;)+ annotate(&quot;text&quot;, x = 2.2, y = 45, label = &quot;Azalea&quot;)+ annotate(&quot;text&quot;, x = 2.2, y = 41, label = &quot;Barbi&quot;)+ annotate(&quot;text&quot;, x = 2.2, y = 35, label = &quot;Rowena&quot;)+ annotate(&quot;text&quot;, x = 2.2, y = 10, label = &quot;Fiona&quot;) Notes Psychological Science has a style guide that asks authors to use the font: Helvetica Neue 57 Condensed roman font I installed that font on machine (found a free .ttf download), then used the showtext library to use that font with ggplot2. warning: this won’t work if you don’t have the font installed, and installing the font could be idiosyncratic, it took me at least an hour library(showtext) font_add(&quot;HelveticaNeue&quot;, regular = &quot;/Users/mattcrump/Library/Fonts/Helvetica-Neue-LT-Std-57-Condensed_22529.ttf&quot;) ## Automatically use showtext to render plots showtext_auto() NS_risk&lt;-c(0,1,3,4,25,45,52,59) S_risk&lt;-c(12,47,4,41,48,35,55,60) plot_df&lt;-data.frame(NS_risk,S_risk) p&lt;-ggplot(plot_df, aes(x=NS_risk,y=S_risk))+ geom_point(shape=18, size=1,fill=&quot;black&quot;)+ geom_smooth(method=&quot;lm&quot;,se=FALSE, color=&quot;black&quot;, size=.35)+ # theme_classic(base_size=12, base_family = &quot;Arial Narrow&quot;)+ theme(axis.title.x=element_text(size=12,family=&quot;HelveticaNeue&quot;), axis.title.y=element_text(size=12, family=&quot;HelveticaNeue&quot;), axis.text =element_text(size=11, family=&quot;HelveticaNeue&quot;, color=&quot;black&quot;), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank())+ xlab(&quot;Average Frequency of Nonsocial Risk&quot;)+ ylab(&quot;Average Frequency of Social Risk&quot;)+ coord_cartesian(xlim=c(0,70), ylim=c(0,70))+ scale_x_continuous(breaks=seq(0,70,10), expand=c(0,0))+ scale_y_continuous(breaks=seq(0,70,10), expand=c(0,0))+ theme(axis.line = element_line(size = .25))+ theme(axis.ticks = element_line(size = .25)) ggsave(&quot;datavis_figs/Calcutt2_Crump.png&quot;, p, width = 3, height = 3) knitr::include_graphics(&quot;datavis_figs/Calcutt2_Crump.png&quot;) Cao, J., Kleiman-Weiner, M., &amp; Banaji, M. R. (2019). People Make the Same Bayesian Judgment They Criticize in Others. Psychological Science, 30, 20–31. Notes 1. ggplot automatically orders factor levels alphabetically, this examples shows a method to rearrange the order of factor levels in the data.frame before plotting studies &lt;- rep(c(&quot;Doctor \\n Study 1 \\n N = 199&quot;, &quot;Butcher \\n Study 2 \\n n = 199&quot;, &quot;Firefighter \\n Study 2 \\n n = 200&quot;, &quot;Construction \\n Worker \\n Study 2 \\n n = 205&quot;), each=3) likely &lt;- rep(c(&quot;Women More Likely&quot;, &quot;Equally Likely&quot;, &quot;Man more Likely&quot;),4) pp &lt;- c(0,90,10, 5,60,35, 2,40,58, 5,60,35)/100 plot_df &lt;- data.frame(pp,studies,likely) plot_df$likely &lt;- factor(plot_df$likely, levels = c(&quot;Women More Likely&quot;, &quot;Equally Likely&quot;, &quot;Man more Likely&quot;)) plot_df$studies &lt;- factor(plot_df$studies, levels = c(&quot;Doctor \\n Study 1 \\n N = 199&quot;, &quot;Butcher \\n Study 2 \\n n = 199&quot;, &quot;Firefighter \\n Study 2 \\n n = 200&quot;, &quot;Construction \\n Worker \\n Study 2 \\n n = 205&quot;)) ggplot(plot_df, aes(x=studies, y=pp, group=likely, fill=likely))+ geom_bar(stat=&quot;identity&quot;, width=.5)+ theme_classic(base_size=10)+ xlab(&quot;&quot;)+ ylab(&quot;Percentage of Participants&quot;)+ scale_y_continuous(breaks=seq(0,1,.1),labels = scales::percent)+ theme(legend.title = element_blank(), axis.ticks.x.bottom = element_blank()) Notes 1. An example of violin plots, which require distributions of numbers for each level 2. An example of using two data.frames in ggplot, one with all of the raw data for each level, and another with the means and confidence intervals. Confidence intervals are computed using the t.test function A &lt;- rexp(200) B &lt;- rnorm(200,3,sd=1) C &lt;- rnorm(200,3,sd=1) D &lt;- rnorm(200,3,sd=1) DV &lt;- c(A,B,C,D) studies &lt;- rep(c(&quot;Doctor \\n Study 1 \\n N = 199&quot;, &quot;Butcher \\n Study 2 \\n n = 199&quot;, &quot;Firefighter \\n Study 2 \\n n = 200&quot;, &quot;Construction \\n Worker \\n Study 2 \\n n = 205&quot;), each=200) plot_df &lt;-data.frame(DV,studies) plot_df$studies &lt;- factor(plot_df$studies, levels = c(&quot;Doctor \\n Study 1 \\n N = 199&quot;, &quot;Butcher \\n Study 2 \\n n = 199&quot;, &quot;Firefighter \\n Study 2 \\n n = 200&quot;, &quot;Construction \\n Worker \\n Study 2 \\n n = 205&quot;)) library(dplyr) means_df &lt;- plot_df %&gt;% group_by(studies) %&gt;% summarise(M=mean(DV), CI_lower = t.test(DV)$conf.int[1], CI_upper = t.test(DV)$conf.int[2]) ggplot(means_df, aes(x=studies,y=M))+ geom_violin(data=plot_df, aes(x=studies,y=DV),fill=&quot;grey&quot;)+ theme_classic(base_size=10)+ xlab(&quot;&quot;)+ ylab(&quot;Evaluation of Person X&quot;)+ scale_y_continuous(breaks=seq(0,7,1))+ coord_cartesian(ylim=c(0,7))+ geom_point()+ geom_errorbar(aes(ymin=CI_lower,ymax=CI_upper), width=.2) Notes: 1. An example of a histogram. Note this is incomplete because the y-axis is not showing percentages… ps &lt;- rnorm(100,0,1) s&lt;-1:100 plot_df&lt;-data.frame(s,ps) ggplot(plot_df, aes(x=ps))+ geom_histogram(fill=&quot;green&quot;, color=&quot;black&quot;)+ coord_cartesian(xlim=c(-4,4))+ theme_classic(base_size=9)+ xlab(&quot;Log Likelihood Ratio&quot;)+ ylab(&quot;Participants (in Each condition)&quot;)+ ggtitle(&quot;Women Performed Surgery&quot;)+ geom_vline(xintercept=0,linetype=2) Notes: 1. customizes color schemes by hard-coding 2. use facet_wrap, and take away the borders of the facet titles Gender &lt;- rep(c(&quot;Men Performed Surgery \\n n = 152&quot;, &quot;Women Performed Surgery \\n n = 142&quot;), each =3) Parameter &lt;- rep(c(&quot;Prior&quot;, &quot;Model \\n Posterior&quot;, &quot;Reported \\n Posterior&quot;), 2) p &lt;- c(.7, .88, .87, .29, .72, .76) ci &lt;- c(.05, .05, .05, .05, .05, .05) plot_df &lt;- data.frame(p, ci, Gender, Parameter) plot_df$Parameter &lt;- factor(plot_df$Parameter, levels = c(&quot;Prior&quot;, &quot;Model \\n Posterior&quot;, &quot;Reported \\n Posterior&quot;)) ggplot(plot_df, aes(x=Parameter, y=p, fill=Parameter))+ geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ facet_wrap(~Gender)+ theme_classic(base_size=11)+ scale_fill_manual(values=c(&quot;#F8766D&quot;, &quot;#7CAE00&quot;, &quot;#C77CFF&quot;))+ ylab(&quot;P(Target = Doctor)&quot;)+ scale_y_continuous(breaks=seq(0,1,.1),labels = scales::percent)+ coord_cartesian(ylim=c(0,1))+ theme(panel.grid = element_blank(), panel.spacing.x = unit(0,&quot;line&quot;), panel.border = element_blank(), panel.background = element_blank())+ theme(strip.background = element_rect(colour = &#39;white&#39;, fill = &#39;white&#39;, size = 0))+ theme(legend.position = &quot;none&quot;) Notes: 1. two linear regression lines using geom_smooth(method=\"lm\") 2. The raw data is not plotted as points evaluation&lt;-c((seq(1,7,.1)+runif(61,-2,2)), (seq(1,7,.1)+runif(61,-2,2))) pTarget &lt;-c((seq(.92,.85,length.out=61)+runif(61,-.1,.1)), (seq(.8,.4,length.out=61)+runif(61,-.5,.5))) Gender &lt;- rep(c(&quot;Man Communicated with ATC&quot;, &quot;Woman Communicated with ATC&quot;), each=61) plot_df&lt;-data.frame(evaluation,pTarget,Gender) plot_df &lt;- plot_df %&gt;% filter(evaluation&gt;=1, evaluation&lt;=7) ggplot(plot_df, aes(x=evaluation,y=pTarget, group=Gender, color=Gender))+ geom_smooth(method=&quot;lm&quot;)+ theme_classic()+ scale_y_continuous(breaks=seq(0,1,.1),labels = scales::percent)+ scale_x_continuous(breaks=seq(1,7,1))+ coord_cartesian(ylim=c(0,1))+ xlab(&quot;Evaluation of Person X&quot;)+ ylab(&quot;P(Target = Pilot)&quot;)+ theme(legend.position=c(0.45,0.2), legend.title=element_blank(), legend.key.size = unit(.5, &quot;cm&quot;))+ theme(legend.key = element_rect(colour = &#39;white&#39;, fill = &#39;white&#39;, size = 1, linetype=&#39;solid&#39;)) Jefferies, L. N., &amp; Lollo, V. D. (2019). Sudden Events Change Old Visual Objects Into New Ones: A Possible Role for Phasic Activation of Locus Coeruleus. Psychological Science, 30, 55–64. Notes: 1. Example of using the ggpubr package and the ggarrange function to put two separate plots side-by-side in a 2-column, 1-row, grid. library(ggpubr) Condition &lt;-rep(c(&quot;No \\n Transient&quot;,&quot;Transient&quot;), each=2) Location &lt;-rep(c(&quot;Outside&quot;,&quot;Inside&quot;),2) MMRT &lt;- c(304,300,290,280) CI_upper &lt;-c(315,310,304,290) CI_lower &lt;-c(295,290,283,270) plot_df &lt;-data.frame(Condition,Location,MMRT,CI_upper,CI_lower) plot_df$Location &lt;- factor(plot_df$Location, levels = c(&quot;Outside&quot;,&quot;Inside&quot;)) vis&lt;-ggplot(plot_df, aes(x=Condition, y=MMRT, group=Location, fill=Location))+ geom_bar(stat=&quot;identity&quot;,position=&quot;dodge&quot;, color=&quot;black&quot;, size=.25)+ theme_classic()+ ylab(&quot;Mean Median RT (ms)&quot;)+ coord_cartesian(ylim=c(230,340))+ scale_y_continuous(breaks=seq(230,340,10))+ scale_fill_brewer(palette=&quot;Greys&quot;, direction=-1)+ theme(legend.position=c(0.55,0.8), legend.title=element_blank(), legend.key.size = unit(.5, &quot;cm&quot;))+ ggtitle(&quot;Visual Group&quot;) Condition &lt;-rep(c(&quot;No \\n Transient&quot;,&quot;Transient&quot;), each=2) Location &lt;-rep(c(&quot;Outside&quot;,&quot;Inside&quot;),2) MMRT &lt;- c(295,290,265,250) CI_upper &lt;-c(305,300,275,260) CI_lower &lt;-c(285,280,255,240) plot_df &lt;-data.frame(Condition,Location,MMRT,CI_upper,CI_lower) plot_df$Location &lt;- factor(plot_df$Location, levels = c(&quot;Outside&quot;,&quot;Inside&quot;)) aud&lt;-ggplot(plot_df, aes(x=Condition, y=MMRT, group=Location, fill=Location))+ geom_bar(stat=&quot;identity&quot;,position=&quot;dodge&quot;, color=&quot;black&quot;, size=.25)+ theme_classic()+ ylab(&quot;Mean Median RT (ms)&quot;)+ coord_cartesian(ylim=c(230,340))+ scale_y_continuous(breaks=seq(230,340,10))+ scale_fill_brewer(palette=&quot;Greys&quot;, direction=-1)+ theme(legend.position=&quot;none&quot;)+ ggtitle(&quot;Auditory Group&quot;) ggarrange(vis,aud) Jouravlev, O., Schwartz, R., Ayyash, D., Mineroff, Z., Gibson, E., &amp; Fedorenko, E. (2019). Tracking Colisteners’ Knowledge States During Language Comprehension. Psychological Science, 30, 3–19. x &lt;- runif(25,-2.5,3) y &lt;- runif(25,-10,15) r &lt;- round(cor(x,y), digits=2) df &lt;- data.frame(x,y) a &lt;- ggplot(df, aes(x=x, y=y))+ geom_point()+ geom_smooth(method=&quot;lm&quot;, se=FALSE)+ xlab(&quot;Social N400&quot;)+ ylab(&quot;Autism-Spectrum \\n Quotient (score)&quot;)+ scale_x_continuous(breaks=seq(-2.5,2.5,2.5))+ coord_cartesian(xlim=c(-2.5,3))+ annotate(&quot;text&quot;,label=paste(&quot;r = &quot;,r), x=2.5, y=10) x &lt;- runif(25,-2.5,3) y &lt;- runif(25,-10,15) r &lt;- round(cor(x,y), digits=2) df &lt;- data.frame(x,y) b &lt;- ggplot(df, aes(x=x, y=y))+ geom_point()+ geom_smooth(method=&quot;lm&quot;, se=FALSE)+ xlab(&quot;Social N400&quot;)+ ylab(&quot;\\&#39;Reading the Mind in the \\n Eyes\\&#39; Test (score&quot;)+ scale_x_continuous(breaks=seq(-2.5,2.5,2.5))+ coord_cartesian(xlim=c(-2.5,3))+ annotate(&quot;text&quot;,label=paste(&quot;r = &quot;,r), x=2.5, y=10) x &lt;- runif(25,-2.5,3) y &lt;- runif(25,-10,15) r &lt;- round(cor(x,y), digits=2) df &lt;- data.frame(x,y) c &lt;- ggplot(df, aes(x=x, y=y))+ geom_point()+ geom_smooth(method=&quot;lm&quot;, se=FALSE)+ xlab(&quot;Social N400&quot;)+ ylab(&quot;Empathy Quotient Test \\n (score&quot;)+ scale_x_continuous(breaks=seq(-2.5,2.5,2.5))+ coord_cartesian(xlim=c(-2.5,3))+ annotate(&quot;text&quot;,label=paste(&quot;r = &quot;,r), x=2.5, y=10) ggarrange(a,b,c,nrow=3, ncol=1) Kim, H., Domenico, S. I. D., &amp; Connelly, B. S. (2019). Self–Other Agreement in Personality Reports: A Meta-Analytic Comparison of Self- and Informant-Report Means. Psychological Science, 30, 129–138. people &lt;- rep(c(&quot;Family&quot;,&quot;Friends&quot;,&quot;Colleagues&quot;,&quot;Strangers&quot;), each=5) big_five &lt;- rep(c(&quot;Emotional \\n Stability&quot;,&quot;Extraversion&quot;,&quot;Openness/ \\n Intellect&quot;, &quot;Agreeableness&quot;,&quot;Consientiousness&quot;), 4) mean_difference &lt;-c(0,.3,.8,.4,.4, c(0,.3,.8,.4,.4)-.2, c(0,.3,.8,.4,.4)-.21, c(0,.3,.8,.4,.4)-.25) df &lt;- data.frame(mean_difference,people,big_five) df$big_five &lt;- factor(df$big_five, levels = c(&quot;Emotional \\n Stability&quot;,&quot;Extraversion&quot;,&quot;Openness/ \\n Intellect&quot;, &quot;Agreeableness&quot;,&quot;Consientiousness&quot;)) df$people &lt;- factor(df$people, levels = c(&quot;Family&quot;,&quot;Friends&quot;,&quot;Colleagues&quot;,&quot;Strangers&quot;)) ggplot(df, aes(x=big_five, y=mean_difference, group=people, shape=people, linetype=people, color=people))+ scale_color_brewer(palette=&quot;Greys&quot;, direction=-1)+ geom_point()+ geom_line()+ xlab(&quot;&quot;)+ ylab(&quot;Mean Difference&quot;)+ coord_cartesian(ylim=c(-.8,.8))+ scale_y_continuous(breaks=seq(-.8,.8,.2))+ theme_classic()+ geom_hline(yintercept=0)+ theme(axis.line.x.bottom = element_blank(), axis.ticks.x.bottom = element_blank(), legend.title = element_blank()) Oh, D., Buck, E. A., &amp; Todorov, A. (2019). Revealing Hidden Gender Biases in Competence Impressions of Faces. Psychological Science, 30, 65–79. Perfecto, H., Donnelly, K., &amp; Critcher, C. R. (2019). Volume Estimation Through Mental Simulation. Psychological Science, 30, 80–91. Smith, S. M., &amp; Krajbich, I. (2019). Gaze Amplifies Value in Decision Making. Psychological Science, 30, 116–128. Uitvlugt, M. G., &amp; Healey, M. K. (2019). Temporal Proximity Links Unrelated News Events in Memory. Psychological Science, 30, 92–104. "],
["data-wrangling.html", "Chapter 5 Data-Wrangling 5.1 What is Data-wrangling 5.2 dplyr basics 5.3 basic dataframe stuff without dplyr 5.4 A couple questions: 5.5 dplyr style 5.6 Data input 5.7 Example Analysis", " Chapter 5 Data-Wrangling 5.1 What is Data-wrangling Data-wrangling is the general process of organizing and transforming data into various formats. For example, loading data into R, pre-processing it to get rid of things you don’t want and keep the things you want, add new things you might want that, arranging the data in different ways to accomplish different kinds of tasks, grouping the data, and summarizing the data, are all common data-wrangling activities. Real-world data often has many imperfections, so data-wrangling is necessary to get the data into a state that is readily analyzable. We will mainly go over the dplyr package, which has a number of fantastic and relatively easy to use tools for data-wrangling. At the same time, it worth developigng your basic programming skills (using loops and logic), as they are also indispensable for solving unusual data-wrangling problems. 5.2 dplyr basics Dplyr reference Hadley Wickham’s, R for Data Science, Chapter 5 Data transformation Data import Cheatsheet library(dplyr) #load the package (make sure it is installed first) df &lt;- starwars # dplyr comes with a data.frame called starwars Take a look at that data in df, what do you see? It lists various characters from starwars, along with many columns that code for different properties of each character 5.3 basic dataframe stuff without dplyr # addressing specific columns df$name df$height df$mass # addressing columns and rows without names df[1,] # row 1 df[,1] # column 1 df[1:4,] # all of the data in rows 1:4 df[,4:5] # all of the data in columns 4:5 df[1:3,6:7] # the data in rows 1 to 3, for column 6 and 7 only # finding a row(s) with specific info df[df$name==&quot;Luke Skywalker&quot;,] df[df$height &gt; 180,] df[df$height &lt; 180 &amp; df$height &gt; 70,] #replace a particular value df[1,2] &lt;- 173 #changes the cell in row 1 column 2 # size of dataframe dim(df) #c(number of rows, number of columns) # cbind to add a column to a data.frame df &lt;- cbind(df, random_number=runif(dim(df)[1],0,1)) # rbind to add rows # this creates a new data frame, binding together the rows 1-2, and 5-6 # note: all of the columns need to be the same new_df &lt;- rbind(df[1:2,],df[5:6,]) # convert a character vector to a factor df$species &lt;- as.factor(df$species) levels(df$species) levels(df$species)[3] &lt;- &quot;hello&quot; # renames the third level, which get&#39;s applied to all listings in the df 5.4 A couple questions: What are the names of all the characters who are taller than 80, shorter than 140, and are female? df[df$height &gt; 80 &amp; df$height &lt; 170 &amp; df$gender == &quot;female&quot;, ]$name How many characters have Tatooine for their homeworld? df[df$homeworld==&quot;Tatooine&quot;,] dim(df[df$homeworld==&quot;Tatooine&quot;,])[1] # counts the NAs tatooine &lt;- df[df$homeworld==&quot;Tatooine&quot;,] tatooine[is.na(tatooine$name)==FALSE,] dim(tatooine[is.na(tatooine$name)==FALSE,])[1] 5.5 dplyr style We now look at dplyr and pipes. The idea here is that we start with a dataframe, then systematically transform one step at a time. At each step we pass the data in it’s new state to the next step. The passing is called piping the data. There is a special operator for this %&gt;% 5.5.1 quick example We start with the entire dataframe df. Then we select only the rows where the height is taller than 100. Then we group by homeworld, and compute the mean birth year. What we get is a new data.frame, showing the mean birth years for each homeworld. This is a common refrain: Dataframe %&gt;% filter %&gt;% group_by %&gt;% summarise library(dplyr) new_df &lt;- df %&gt;% filter(height &gt; 100) %&gt;% group_by(homeworld) %&gt;% summarise(mean_birth_year = mean(birth_year,na.rm=TRUE)) 5.5.2 filter We can filter the data by properties of particular columns # make a new dataframe that only include rows where the height is greater than 120 new_df &lt;- df %&gt;% filter(height &gt; 120) # multiple filters are seperated by a comma new_df &lt;- df %&gt;% filter(height &gt; 120, height &lt; 180, birth_year &gt; 20) # more examples of differen logical operators new_df &lt;- df %&gt;% filter(gender == &quot;male&quot;) # == equals identity (same as) new_df &lt;- df %&gt;% filter(gender != &quot;male&quot;) # != not equal to new_df &lt;- df %&gt;% filter(eye_color %in% c(&quot;blue&quot;,&quot;yellow&quot;) == TRUE) # looks for matches to blue and yellow # &lt;= less than or equal to # &gt;= greater than or equal to new_df &lt;- df %&gt;% filter(height &gt;= 120, height &lt;= 180) new_df &lt;- df %&gt;% filter(height &gt; 120 &amp; height &lt; 180) # &amp; AND new_df &lt;- df %&gt;% filter(skin_color == &quot;fair&quot; | skin_color == &quot;gold&quot;) # | OR 5.5.3 group_by and summarise group_by() let’s us grab parts of the data based on the levels in the column summarise() applies a function to each of the groups that are created # counts the number of names, for each hair color new_df &lt;- df %&gt;% group_by(hair_color) %&gt;% summarise(counts=length(name)) # counts names, for each combination of hair and eye color new_df &lt;- df %&gt;% group_by(hair_color,eye_color) %&gt;% summarise(counts=length(name)) 5.5.4 focus on summarise summarise is very powerful. Using summarise we can apply any function we want to each of the groups. This includes intrinsic R functions, and functions of our own design. And, we can add as many as we want. What we get back are new dataframes with columns for each group, and new columns with variables containing the data we want from the analysis new_df &lt;- df %&gt;% group_by(hair_color,eye_color) %&gt;% summarise(mean_years = mean(birth_year,na.rm=TRUE), sd_years = sd(birth_year,na.rm=TRUE), counts = length(name)) 5.5.5 Mutate Use mutate to change or add a column # change numbers in the height column by subtracting 100 new_df &lt;- df %&gt;% mutate(height=height-100) # make a new column dividing height by mass new_df &lt;- df %&gt;% mutate(hm_ratio = height/mass) 5.5.6 Select Use select to select columns of interest and return a dataframe only with those columns new_df &lt;- df %&gt;% select(name,height,mass) 5.5.7 Star wars questions and answers use dplyr to find how many movies each character appeared in. Return a table that lists the names, and the number of films # two ways to do the same thing new_df &lt;- df %&gt;% select(name,films) %&gt;% group_by(name) %&gt;% mutate(films = length(unlist(films))) new_df &lt;- df %&gt;% select(name,films) %&gt;% group_by(name) %&gt;% summarise(films = length(unlist(films))) How many characters are in each movie? dplyr isn’t always necessary for every question table(unlist(df$films)) ## ## A New Hope Attack of the Clones Return of the Jedi ## 18 40 20 ## Revenge of the Sith The Empire Strikes Back The Force Awakens ## 34 16 11 ## The Phantom Menace ## 34 What is the mean height and mass of characters with blue eyes? new_df &lt;- df %&gt;% filter(eye_color==&quot;blue&quot;) %&gt;% summarise(mean_height = mean(height,na.rm=TRUE), mean_mass = mean(mass,na.rm=TRUE)) 5.6 Data input Before we wrangle with data, we need to get it into R. There are many ways to do that. All of the following examples assume you have a data folder in your workspace that contains all the data files we will be using. Download this .zip file https://github.com/CrumpLab/statisticsLab/raw/master/RstudioCloud.zip. Unzip the file. Then copy the data folder into your R markdown project folder. WARNING: loading files requires you to tell R exactly where the file is on your computer. This can involve specifying the entire file path (the drive, all of the folder, and then the filename). These examples avoid this complete filename nonsense by putting the files in a data folder in your R project folder. Then, we just need to specify the folder and the filename. In this case, the folder will always be data. In general, R by default attempts to load files from the current working directory, which is automatically set to your project folder when you are working in an R-studio project. # loading a csv file using read.csv hsq &lt;- read.csv(&quot;data/hsq.csv&quot;) # alternative using fread library(data.table) hsq &lt;- fread(&quot;data/hsq.csv&quot;) # creates a data.table, similar to a data.frame # loading an SPSS sav file library(foreign) spss &lt;- read.spss(&quot;data/02_NYC_Salary_City_2016.sav&quot;, to.data.frame=TRUE) 5.6.1 Other helpful libraries for reading in files libary readxl let’s you read in excel files library googlesheets let’s you read in google spreadsheets function scan is a powerful and all purpose text input function, often helpful in very messy situations where you want to read in line-by-line load for R data files there are several read. functions for specific situations. library jsonlite for json data structures and many more, this is really something that you will learn more about on a case-by-case basis as you have to deal with particular data formats. 5.7 Example Analysis This example is taken from https://crumplab.github.io/statisticsLab/lab-10-factorial-anova.html#r-10. The data file is stroop_stand.csv, and can be found here https://github.com/CrumpLab/statisticsLab/tree/master/data 5.7.1 Load the data and libraries you will use library(data.table) library(dplyr) library(ggplot2) all_data &lt;- fread(&quot;data/stroop_stand.csv&quot;) 5.7.2 Pre-processing Pre-processing can include many steps. Here, we convert the data from wide to long format, and make a new data frame. RTs &lt;- c(as.numeric(unlist(all_data[,1])), as.numeric(unlist(all_data[,2])), as.numeric(unlist(all_data[,3])), as.numeric(unlist(all_data[,4])) ) Congruency &lt;- rep(rep(c(&quot;Congruent&quot;,&quot;Incongruent&quot;),each=50),2) Posture &lt;- rep(c(&quot;Stand&quot;,&quot;Sit&quot;),each=100) Subject &lt;- rep(1:50,4) stroop_df &lt;- data.frame(Subject,Congruency,Posture,RTs) 5.7.3 Checks It is important to check the data you are analyzing before you analyze. The checks you make depend on the questions you are trying to answer. Here we check the number of subjects in each condition. This is a 2x2 repeated measures design, each subject should have 4 means num_subjects &lt;- stroop_df %&gt;% group_by(Subject) %&gt;% summarise(counts = length(Subject)) total_subjects &lt;- length(num_subjects$Subject) total_has_four &lt;- num_subjects$counts == 4 sum(total_has_four) == total_subjects ## [1] TRUE Are there any subjects with huge mean RTs? Could indicate something weird happened. hist(stroop_df$RTs) 5.7.4 Exclusion If you are going to exlcude subjects from analysis, then justify your exclusion criterion, and then eliminate subject data from the data frame. We will not exlcude any subjects here. # no exclusions 5.7.5 Analysis Now you can begin analysis. This experiment asked whether the Stroop effect (difference between mean incongruent and mean congruent), depends on whether people are sitting or standing. Let’s get the means, make a tbale, then plot the data. 5.7.6 table of 2x2 means overall_means &lt;- stroop_df %&gt;% group_by(Posture,Congruency) %&gt;% summarise(meanRT = mean(RTs), SEMRT = (sd(RTs)/sqrt(length(RTs)))) # make a table of overall means knitr::kable(overall_means) Posture Congruency meanRT SEMRT Sit Congruent 821.9232 16.60384 Sit Incongruent 940.7855 17.91041 Stand Congruent 807.9599 14.93521 Stand Incongruent 903.9131 15.34939 5.7.7 plot of 2x2 means ggplot(overall_means, aes(x=Posture, y=meanRT, group=Congruency, fill=Congruency))+ geom_bar(stat=&quot;identity&quot;,position=&quot;dodge&quot;)+ theme_classic(base_size=12)+ ylab(&quot;Mean Reaction Time (ms)&quot;)+ geom_errorbar(aes(ymin=meanRT-SEMRT, ymax=meanRT+SEMRT), position=position_dodge(width=0.9), width=.2, color=&quot;black&quot;)+ coord_cartesian(ylim=c(750,1000)) 5.7.8 Repeated measure ANOVA # Make sure Subjecdt is a factor stroop_df$Subject &lt;- as.factor(stroop_df$Subject) aov_out &lt;- aov(RTs~Posture*Congruency + Error(Subject/(Posture*Congruency)), stroop_df) #print summary of ANOVA table summary(aov_out) ## ## Error: Subject ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Residuals 49 2250739 45933 ## ## Error: Subject:Posture ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Posture 1 32303 32303 7.33 0.00931 ** ## Residuals 49 215948 4407 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Error: Subject:Congruency ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Congruency 1 576822 576822 342.5 &lt;2e-16 *** ## Residuals 49 82535 1684 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Error: Subject:Posture:Congruency ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Posture:Congruency 1 6560 6560 8.964 0.00431 ** ## Residuals 49 35859 732 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # prints a nicer ANOVA table summary_out &lt;- summary(aov_out) library(xtable) knitr::kable(xtable(summary_out)) Df Sum Sq Mean Sq F value Pr(&gt;F) Residuals 49 2250738.636 45933.4416 NA NA Posture 1 32303.453 32303.4534 7.329876 0.0093104 Residuals1 49 215947.614 4407.0942 NA NA Congruency 1 576821.635 576821.6349 342.452244 0.0000000 Residuals 49 82534.895 1684.3856 NA NA Posture:Congruency 1 6560.339 6560.3389 8.964444 0.0043060 Residuals 49 35859.069 731.8177 NA NA # prints means for each effect print(model.tables(aov_out,&quot;means&quot;), format=&quot;markdown&quot;) ## Tables of means ## Grand mean ## ## 868.6454 ## ## Posture ## Posture ## Sit Stand ## 881.4 855.9 ## ## Congruency ## Congruency ## Congruent Incongruent ## 814.9 922.3 ## ## Posture:Congruency ## Congruency ## Posture Congruent Incongruent ## Sit 821.9 940.8 ## Stand 808.0 903.9 5.7.9 Example Write-Up We submitted the mean reaction times for each subject in each condition to a 2 (Congruency: congruecnt vs. incongruent) x 2 (Posture: Standing vs. Sitting) repeated measures ANOVA. There was a main effect of Congruency, F (1, 49) = 342.45, MSE = 1684.39, p &lt; 0.001. Mean reaction times were slower for incongruent (922 ms) than congruent groups (815 ms). There main effect of Posture was significant, F (1, 49) = 7.33, MSE = 4407.09, p =.009. Mean reaction times were slower for sitting (881 ms) than standing groups (855 ms). The two-way interaction between Congruency and Posture was significant, F (1, 49) = 8.96, MSE = 731.82, p &lt; 0.004. The Stroop effect was 23 ms smaller in the standing than sitting conditions. "],
["references.html", "References", " References "]
]
